# Регулярные выражения в Java

## Введение - что это и зачем нужно

Полезные ссылки:
- [regex101](https://regex101.com)

Регулярные выражения (regex) — это инструмент для работы с текстом. Они позволяют находить, проверять и заменять текстовые шаблоны в строках. Регулярные выражения используются в различных задачах, таких как валидация ввода, парсинг текста, поиск и замена.

## Основной синтаксис регулярных выражений в Java

Регулярные выражения в Java следуют синтаксису, который схож с синтаксисом в других языках программирования. Основные элементы включают:

### **Символы**: `a`, `b`, `1`, `2`, и т.д.  
Обычные символы в регулярных выражениях представляют сами себя. Например:  
- 'a' соответствует букве 'a'
- '1' соответствует цифре '1'
- '@' соответствует символу '@'

### **Мета-символы**: `.`, `*`, `+`, `?`, `|`, `^`, `$`, `[]`, `()`, `{}`, `\`  
Мета-символы имеют специальное значение в регулярных выражениях:
- '.' - соответствует любому одиночному символу, кроме новой строки
- '*' - соответствует нулю или более повторений предыдущего символа или выражения
- '+' - соответствует одному или более повторений предыдущего символа или выражения
- '?' - делает предыдущий символ или выражение необязательным
- '|' - означает "или", например 'a|b' соответствует 'a' или 'b'
- '^' - соответствует началу строки
- '$' - соответствует концу строки
- '[]' - определяет набор символов
- '()' - группирует выражения и создает захватывающие группы
- '{}' - определяет точное количество повторений
- '' - экранирует специальные символы

### **Классы символов**: `[abc]`, `[a-zA-Z]`, `\d`, `\w`, `\s`  
- '[abc]' - соответствует любому из символов a, b или c
- '[a-zA-Z]' - соответствует любой букве английского алфавита (верхнего или нижнего регистра)
- '\d' - соответствует любой цифре (эквивалентно [0-9])
- '\w' - соответствует любому буквенно-цифровому символу или подчеркиванию (эквивалентно [a-zA-Z0-9_])
- '\s' - соответствует любому пробельному символу (пробел, табуляция, новая строка)

### **Квантификаторы**: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}`  
- '*' - ноль или более раз
- '+' - один или более раз
- '?' - ноль или один раз
- '{n}' - ровно n раз
- '{n,}' - n или более раз
- '{n,m}' - от n до m раз

### **Группы и захваты**: `(abc)`, `(?:abc)`, `(?<name>abc)`
- '(abc)' - группирует 'abc' и создает захватывающую группу
- '(?:abc)' - группирует 'abc', но не создает захватывающую группу
- '(?<name>abc)' - создает именованную захватывающую группу


#### Захватывающие группы

Захватывающие группы обозначаются круглыми скобками '()' и выполняют две основные функции:

1. Группировка элементов регулярного выражения.
2. Захват и сохранение части совпадения для дальнейшего использования.

#### Примеры:

1. '(abc)+' - соответствует одному или более повторениям 'abc' и сохраняет каждое совпадение.
2. '(\d{2})-(\d{2})-(\d{4})' - соответствует дате в формате "дд-мм-гггг" и сохраняет день, месяц и год отдельно.

Захваченные группы можно использовать:
- В самом регулярном выражении с помощью обратных ссылок (\1, \2, и т.д.).
- В коде для извлечения конкретных частей совпадения.

#### Именованные захватывающие группы

Именованные захватывающие группы позволяют присвоить имя группе:

'(?<name>abc)' - создает именованную захватывающую группу с именем "name".

Пример:
'(?<day>\d{2})-(?<month>\d{2})-(?<year>\d{4})' - позволяет обращаться к захваченным значениям по именам "day", "month", "year".

#### Незахватывающие группы

Незахватывающие группы обозначаются '(?:)' и используются только для группировки элементов без сохранения совпадения.

#### Преимущества незахватывающих групп:

1. Повышение производительности, так как не тратятся ресурсы на сохранение совпадений.
2. Упрощение структуры регулярного выражения, когда захват не нужен.

#### Примеры:

1. '(?:abc)+' - соответствует одному или более повторениям 'abc', но не сохраняет их.
2. 'http(?:s)?://' - соответствует 'http://' или 'https://', но не сохраняет 's'.

## Сравнение захватывающих и незахватывающих групп

Рассмотрим пример:

Строка: "apple banana cherry"
Регулярное выражение: '(a\w+)\s+(b\w+)\s+(c\w+)'

Захватывающие группы сохранят:
1. "apple"
2. "banana"
3. "cherry"

Если изменить на: '(?:a\w+)\s+(b\w+)\s+(?:c\w+)'

Будет сохранена только одна группа:
1. "banana"

## Применение в Java

```java
import java.util.regex.*;

Pattern pattern = Pattern.compile("(\\w+)=(\\d+)");
Matcher matcher = pattern.matcher("key=123");

if (matcher.find()) {
    String key = matcher.group(1);  // "key"
    String value = matcher.group(2);  // "123"
}
```

Для именованных групп:

```java
Pattern pattern = Pattern.compile("(?<key>\\w+)=(?<value>\\d+)");
Matcher matcher = pattern.matcher("key=123");

if (matcher.find()) {
    String key = matcher.group("key");  // "key"
    String value = matcher.group("value");  // "123"
}
```


Пример регулярного выражения: `\d{3}-\d{2}-\d{4}` — соответствует строкам формата "123-45-6789". Аналогично можно использовать `(\d{3})-(\d{2})-(\d{4})` или `[0-9]{3}-[0-9]{2}-[0-9]{4}` или `\d{3,3}-\d{2,2}-\d{4,4}` или `\b\d{3}-\d{2}-\d{4}\b` или `^\d{3}-\d{2}-\d{4}$`

## Класс шаблонов Pattern

Класс `Pattern` представляет собой скомпилированное регулярное выражение. Он используется для создания объектов шаблонов.

### Пример:

```java
Pattern pattern = Pattern.compile("\\d{3}-\\d{2}-\\d{4}");
```

## Класс Matcher

Класс `Matcher` используется для выполнения операций сопоставления на строке с использованием объекта `Pattern`.

### Пример:

```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;

Pattern pattern = Pattern.compile("\\d{3}-\\d{2}-\\d{4}");
Matcher matcher = pattern.matcher("123-45-6789");

if (matcher.matches()) {
    System.out.println("Строка соответствует шаблону");
}
```

## Класс PatternSyntaxException

Класс `PatternSyntaxException` используется для обработки ошибок синтаксиса в регулярных выражениях.

### Пример:

```java
try {
    Pattern pattern = Pattern.compile("\\d{3}-\\d{2}-\\d{4");
} catch (PatternSyntaxException e) {
    System.out.println("Ошибка синтаксиса: " + e.getDescription());
}
```

## Интерфейс MatchResult

Интерфейс `MatchResult` предоставляет методы для получения информации о результате сопоставления.

### Пример:

```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.regex.MatchResult;

Pattern pattern = Pattern.compile("(\\d{3})-(\\d{2})-(\\d{4})");
Matcher matcher = pattern.matcher("123-45-6789");

if (matcher.matches()) {
    MatchResult result = matcher.toMatchResult();
    System.out.println("Полное совпадение: " + result.group(0));
    System.out.println("Первая группа: " + result.group(1));
}
```

## Важные моменты

- Мы создаем объект шаблона, вызывая `Pattern.compile()`, конструктора нет.
- `compile()` — статический метод в классе `Pattern`.
- Мы создаем объект `Matcher` с помощью `matcher()` на объектах класса `Pattern`.
- `Pattern.matches()` является статическим методом, который используется для проверки того, соответствует ли данный текст в целом шаблону или нет.
- `find()` используется для поиска нескольких вхождений шаблонов в тексте.
- Мы можем разделить текст на основе шаблона разделителя с помощью метода `split()`.

### Примеры:

#### Проверка соответствия шаблону:

```java
boolean isMatch = Pattern.matches("\\d{3}-\\d{2}-\\d{4}", "123-45-6789");
System.out.println("Соответствует ли строка шаблону? " + isMatch);
```

#### Поиск нескольких вхождений:

```java
Pattern pattern = Pattern.compile("\\d+");
Matcher matcher = pattern.matcher("123 456 789");

while (matcher.find()) {
    System.out.println("Найдено: " + matcher.group());
}
```

#### Разделение текста:

```java
Pattern pattern = Pattern.compile("\\s+");
String[] parts = pattern.split("Java регулярные выражения");

for (String part : parts) {
    System.out.println(part);
}
```

## Полезная ссылка

- [Lesson: Regular Expressions (The Java™ Tutorials > Essential Java Classes) (oracle.com)](https://docs.oracle.com/javase/tutorial/essential/regex/)

- [digitalocean](https://www.digitalocean.com/community/tutorials/regular-expression-in-java-regex-example)

- [java_regex](https://www.w3schools.com/java/java_regex.asp)
